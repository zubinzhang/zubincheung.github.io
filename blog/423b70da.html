<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据库设计-范式 | Zubin | Later Equals Never</title>

  
  <meta name="author" content="Zubin">
  

  
  <meta name="description" content="范式是符合某一种级别的关系模式的集合。关系型数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。范式越高，冗余最低，一般到三范式即可，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余">
  

  
  
  <meta name="keywords" content="MySQL,数据库设计">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="数据库设计-范式"/>

  <meta property="og:site_name" content="Zubin"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Zubin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Zubin</a>
    </h1>
    <p class="site-description">Later Equals Never</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>数据库设计-范式</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/423b70da.html" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-01T02:15:58.000Z">
          2018-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>范式是符合某一种级别的关系模式的集合。关系型数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd 范式（BCNF）、第四范式（4NF）和第五范式（5NF）。<br>范式越高，冗余最低，一般到三范式即可，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余</p>
<span id="more"></span>

<h2 id="一、第一范式（1NF）：确保每列的原子性"><a href="#一、第一范式（1NF）：确保每列的原子性" class="headerlink" title="一、第一范式（1NF）：确保每列的原子性"></a>一、第一范式（1NF）：确保每列的原子性</h2><p>数据表中的每一列（每个字段）必须是不可拆分的最小单元</p>
<table>
<thead>
<tr>
<th align="left">用户 ID</th>
<th align="left">姓名</th>
<th align="left">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">张三</td>
<td align="left">0755-88888888 18888888888</td>
</tr>
</tbody></table>
<p>上面的电话字段可以继续分固定电话和手机</p>
<table>
<thead>
<tr>
<th align="left">用户 ID</th>
<th align="left">姓名</th>
<th align="left">固定电话</th>
<th align="left">手机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">张三</td>
<td align="left">0755-88888888</td>
<td align="left">18888888888</td>
</tr>
</tbody></table>
<h2 id="二、第二范式-2NF-：非键字段必须依赖于键字段"><a href="#二、第二范式-2NF-：非键字段必须依赖于键字段" class="headerlink" title="二、第二范式(2NF)：非键字段必须依赖于键字段"></a>二、第二范式(2NF)：非键字段必须依赖于键字段</h2><p>如果一个关系满足 1NF，并且除了主键以外的其它列，都依赖于该主键。也就是说在一个数据库表中必须有一个主键，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p>
<p>比如说要设计一个订单信息表，所以要将订单编号和商品编号作为数据库的联合主键</p>
<table>
<thead>
<tr>
<th align="left">订单编号</th>
<th align="left">商品编号</th>
<th align="left">商品名称</th>
<th align="left">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">p00001</td>
<td align="left">宝马</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>商品名称跟订单编号无关而仅仅跟商品编号有关，这里违反了 2NF 的设计原则，会存在如下问题：</p>
<ol>
<li><strong>数据冗余</strong>：<br>一个产品销售了 n 次，“商品名称”就重复 n 次。</li>
<li><strong>更新异常</strong>：<br>若调整了某商品的名称，数据表中所有行的“商品名称”值都要更新，否则会出现同一个商品名称不同的情况。</li>
<li><strong>插入异常</strong>：<br>假设要新增新的商品，暂时还没有订单。这样，由于还没有“订单编号”关键字，“商品编号”和“商品名称”也无法记录入数据库。</li>
<li><strong>删除异常</strong>：<br>假设要一批商品，这些商品信息就应该从数据库表中删除，与此同时，销售信息也被删除了。</li>
</ol>
<p>所以上面的表实际上可以拆分为</p>
<table>
<thead>
<tr>
<th align="left">订单编号</th>
<th align="left">商品编号</th>
<th align="left">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">p00001</td>
<td align="left">1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">商品编号</th>
<th align="left">商品名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">p00001</td>
<td align="left">宝马</td>
</tr>
</tbody></table>
<h2 id="三、第三范式-3NF-：确保每列都和主键列直接相关-而不是间接相关"><a href="#三、第三范式-3NF-：确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="三、第三范式(3NF)：确保每列都和主键列直接相关,而不是间接相关"></a>三、第三范式(3NF)：确保每列都和主键列直接相关,而不是间接相关</h2><p>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。<br>满足第三范式的数据库表应该不存在如下依赖关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字段 → 非关键字段x → 非关键字段y</span><br></pre></td></tr></table></figure>

<p>比如设计订单信息表</p>
<table>
<thead>
<tr>
<th align="left">订单编号</th>
<th align="left">商品编号</th>
<th align="left">数量</th>
<th>业务员 Id</th>
<th>业务员姓名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">p00001</td>
<td align="left">1</td>
<td>10001</td>
<td>张三</td>
</tr>
</tbody></table>
<p>明显有 业务员姓名 -&gt; 业务员 Id -&gt; 订单编号 的依赖关系，它也会存在 <strong>数据冗余</strong>、<strong>更新异常</strong>、<strong>插入异常</strong>和 <strong>删除异常</strong> 的情况，上面表可以拆分为：</p>
<table>
<thead>
<tr>
<th align="left">订单编号</th>
<th align="left">商品编号</th>
<th align="left">数量</th>
<th>业务员 Id</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">p00001</td>
<td align="left">1</td>
<td>10001</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">业务员 Id</th>
<th align="left">业务员姓名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">张三</td>
</tr>
</tbody></table>
<p>这样的数据库表是符合第三范式的，消除了 <strong>数据冗余</strong>、<strong>更新异常</strong>、<strong>插入异常</strong>和 <strong>删除异常</strong>。</p>
<h2 id="四、Boyce-Codd-范式（BCNF）：主属性不依赖于主属性"><a href="#四、Boyce-Codd-范式（BCNF）：主属性不依赖于主属性" class="headerlink" title="四、Boyce-Codd 范式（BCNF）：主属性不依赖于主属性"></a>四、Boyce-Codd 范式（BCNF）：主属性不依赖于主属性</h2><p>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。<br>假设仓库管理关系表为：</p>
<table>
<thead>
<tr>
<th align="left">仓库编号</th>
<th align="left">商品编号</th>
<th align="left">管理员编号</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">000001</td>
<td align="left">10001</td>
<td>10</td>
</tr>
</tbody></table>
<p>假设一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(仓库编号,商品编号) →(管理员编号,数量)</span><br><span class="line">(管理员编号,商品编号) → (仓库编号,数量)</span><br></pre></td></tr></table></figure>

<p>所以，(仓库编号,商品编号)和(管理员编号,商品编号)都是候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(仓库编号) → (管理员编号)</span><br><span class="line">(管理员编号) → (仓库编号)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>删除异常：<br>当仓库被清空后，所有”商品编号”和”数量”信息被删除的同时，”仓库编号”和”管理员编号”信息也被删除了。</p>
</li>
<li><p>插入异常：<br>当仓库没有存储任何物品时，无法给仓库分配管理员。</p>
</li>
<li><p>更新异常：<br>如果仓库换了管理员，则表中所有行的管理员编号 都要修改。</p>
</li>
</ol>
<p>把仓库管理关系表分解为二个关系表：</p>
<table>
<thead>
<tr>
<th align="left">仓库编号</th>
<th align="left">商品编号</th>
<th align="left">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000001</td>
<td align="left">000001</td>
<td align="left">10</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">仓库编号</th>
<th align="left">管理员编号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">10001</td>
</tr>
</tbody></table>
<p>这样的数据库表是符合 BCNF 范式的，消除了删除异常、插入异常和更新异常。</p>
<p>还可以这么说：<strong>若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到 BCNF</strong>。</p>
<h2 id="五、-第四范式-4NF-：要求把同一表内的多对多关系删除。"><a href="#五、-第四范式-4NF-：要求把同一表内的多对多关系删除。" class="headerlink" title="五、 第四范式(4NF)：要求把同一表内的多对多关系删除。"></a>五、 第四范式(4NF)：要求把同一表内的多对多关系删除。</h2><p>当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。</p>
<p>下面用户表符合 3NF ，但在某些情况下，比如说有两个手机号码时，这样的表还是不合理的，违反了 4NF。</p>
<table>
<thead>
<tr>
<th align="left">用户 ID</th>
<th align="left">姓名</th>
<th align="left">固定电话</th>
<th align="left">手机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">张三</td>
<td align="left">0755-88888888</td>
<td align="left">18888888888</td>
</tr>
<tr>
<td align="left">10001</td>
<td align="left">张三</td>
<td align="left">0755-88888888</td>
<td align="left">18888888889</td>
</tr>
</tbody></table>
<p>就可以拆分为固定电话表(用户 ID，固定电话)和手机号码表(用户 ID，手机号码)</p>
<p>所以只有在某些特殊情况下，要考虑将表规范到第四范式。</p>
<h2 id="六、-第五范式-5NF-：最终范式。"><a href="#六、-第五范式-5NF-：最终范式。" class="headerlink" title="六、 第五范式(5NF)：最终范式。"></a>六、 第五范式(5NF)：最终范式。</h2><p>满足第四范式条件下，表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。<br>比如一个销售信息表（销售人员，供应商，产品）。<br>在某些情况下，这个表中会产生一些冗余。可以将表分解为：</p>
<ul>
<li>销售人员供应商表（销售人员，供应商）；</li>
<li>销售人员产品表（销售人员，产品）；</li>
<li>供应商产品表（供应商，产品）</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据库/">数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/MySQL/">MySQL</a><a href="/tags/数据库设计/">数据库设计</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 Zubin
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>