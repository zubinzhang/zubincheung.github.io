<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MySQL索引优化 | Zubin | Later Equals Never</title>

  
  <meta name="author" content="Zubin">
  

  
  <meta name="description" content="不使用索引的情况
如果 mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果 key_part 1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：

1SELECT * FROM table_name where key_part1 &amp;gt; 1 and key_par">
  

  
  
  <meta name="keywords" content="学习笔记,MySQL">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="MySQL索引优化"/>

  <meta property="og:site_name" content="Zubin"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Zubin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Zubin</a>
    </h1>
    <p class="site-description">Later Equals Never</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>MySQL索引优化</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/blog/6dd28e9b.html" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-13T02:37:13.000Z">
          2019-01-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="不使用索引的情况"><a href="#不使用索引的情况" class="headerlink" title="不使用索引的情况"></a>不使用索引的情况</h3><ol>
<li>如果 mysql 估计使用索引比全表扫描更慢，则不使用索引。<br>例如：如果 key_part 1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">where</span> key_part1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> key_part1 <span class="operator">&lt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果使用 heap 表并且 where 条件中不用＝索引列，其他 &gt; 、 &lt; 、 &gt;&#x3D; 、 &lt;&#x3D; 均不使 用索引（MyISAM 和 innodb 表使用索引）；</p>
</li>
<li><p>使用 or 分割的条件，如果 or 前的条件中的列有索引，后面的列中没有索引，那么涉及到的索引都不会使用。</p>
</li>
<li><p>如果创建复合索引，如果条件中使用的列不是索引列的第一部分；（不是前缀索引）</p>
</li>
<li><p>如果 like 是以％开始；</p>
</li>
<li><p>对 where 后边条件为字符串的一定要加引号，字符串如果为数字 mysql 会自动转 为字符串，但是不使用索引。</p>
</li>
</ol>
<h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><p>如果索引正在工作， Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使 用。</p>
<p>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，</p>
<p>该值较高。通常说明表索引不正确或写入的查询没有利用索引。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="具体优化查询语句"><a href="#具体优化查询语句" class="headerlink" title="具体优化查询语句"></a>具体优化查询语句</h3><ol>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，建议使用默认值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"># 可以在 num 上设置默认值 <span class="number">0</span>，确保表中 num 列没有 <span class="keyword">null</span> 值</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符</li>
</ol>
<p>MySQL 只有对以下操作符才使用索引：&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN，以及某些时候的 LIKE。</p>
<p>可以在 LIKE 操作中使用索引的情形是指另一个操作数不是以通配符（%或者_）开头的情形。例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;Mich%&#x27;</span>; # 这个查询将使用索引，</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;%ike&#x27;</span>; #这个查询不会使用索引。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应尽量避免在 where 子句中使用 or 来连接条件,所有的 or 条件都必须是独立索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"># 可以使用 <span class="keyword">UNION</span> 合并查询：</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>in 和 not in 也要慎用</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">对于连续的数值，能用 <span class="keyword">between</span> 就不要用 <span class="keyword">in</span> 了：</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果在 where 子句中使用参数，也会导致全表扫描。</li>
</ol>
<p>因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推 迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span>;</span><br><span class="line"># 可以改为强制查询使用索引</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span>;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>应尽量避免在 where 子句中对字段进行表达式操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"># 应改为:</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span>\<span class="operator">*</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>应尽量避免在 where 子句中对字段进行函数操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>; <span class="comment">--name</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> datediff(<span class="keyword">day</span>,createdate,<span class="string">&#x27;2005-11-30&#x27;</span>)<span class="operator">=</span><span class="number">0</span>; <span class="comment">--‘2005-11-30’</span></span><br><span class="line">#  应改为:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> createdate<span class="operator">&gt;=</span><span class="string">&#x27;2005-11-30&#x27;</span> <span class="keyword">and</span> createdate<span class="operator">&lt;</span><span class="string">&#x27;2005-12-1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>很多时候用 exists 代替 in 是一个好的选择：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="keyword">select</span> num <span class="keyword">from</span> b);</span><br><span class="line">用下面的语句替换：</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num<span class="operator">=</span>a.num);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>并不是所有索引对查询都有效，</li>
</ol>
<p>SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p>
<ol start="11">
<li>索引并不是越多越好，</li>
</ol>
<p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据库/">数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/学习笔记/">学习笔记</a><a href="/tags/MySQL/">MySQL</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 Zubin
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>